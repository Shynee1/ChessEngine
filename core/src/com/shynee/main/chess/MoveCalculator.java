package com.shynee.main.chess;

import java.util.*;

/**
 * MoveCalculator -- Used to calculate and store all possible moves in a chess board.
 * The general idea is that there is a HashMap of pseudo moves that is precomputed at the start of the game.
 * This HashMap contains a square as its key and a list of the square's pseudo moves as its value.
 * These pseudo moves represent all possible moves for the piece at the square, regardless of check or other pieces.
 * This means that the only time a set of pseudo moves is recalculated is when the piece they correspond to moves.
 * Legal moves are generated by iterating through all pseudo moves and removing the ones that aren't legal.
 * This vastly improves the efficiency of legal move calculation, allowing all legal moves to be recomputed very quickly.
 */
public class MoveCalculator {

    private final HashMap<Integer, int[]> directionOffsets;

    // Updated every precomputation
    private HashMap<Square, List<Move>> pseudoMoves;
    private Square[] squares;
    private ChessBoard board;

    // Updated every recomputation
    private List<Move> possibleMoves;
    private boolean primaryPieceColor;
    private boolean playerColor;
    private int squarePosition;
    private Square square;

    public MoveCalculator() {
        directionOffsets = new HashMap<>();
        directionOffsets.put(0, new int[]{7, 8, 9, -1, 1, -9, -8, -7});
        directionOffsets.put(1, new int[]{7, 8, 9, -1, 1, -9, -8, -7});
        directionOffsets.put(2, new int[]{7, 9, -7, -9});
        directionOffsets.put(3, new int[]{15, 17, 6, 10, -15, -17, -6, -10});
        directionOffsets.put(4, new int[]{8, 1, -8, -1});
        directionOffsets.put(5, new int[]{8, 7, 9});
    }

    /**
     * Precomputes the pseudo moves for all pieces on the board.
     * @param chessBoard Representation of the current board state.
     * @param playerColor Color of the non-AI player.
     */
    public void precomputeMoves(ChessBoard chessBoard, boolean playerColor){
        this.pseudoMoves = new HashMap<>();
        this.board = chessBoard;
        this.squares = chessBoard.getSquares();
        this.playerColor = playerColor;

        for (Square square : squares) {
            if (square.hasPiece()) {
                pseudoMoves.put(square, calculateMove(square));
            }
        }
    }

    /**
     * Recomputes pseudo moves for a given piece after they have moved.
     * @param chessBoard Representation of the current board state.
     * @param previousSquare Square that the piece was previously on.
     * @param newSquare Square that the piece is currently on.
     */
    public void recomputeMoves(ChessBoard chessBoard, Square previousSquare, Square newSquare){
        this.squares = chessBoard.getSquares();
        this.board = chessBoard;

        // Debugging code for null pieces
        if (newSquare.getPiece() == null){
            System.out.println(FenUtility.savePosition(board));
            System.out.println(previousSquare.getArrayPosition()+":"+ newSquare.getArrayPosition());
        }

        pseudoMoves.remove(previousSquare);
        pseudoMoves.put(newSquare, calculateMove(newSquare));

    }

    /**
     * Generates all legal moves for a given player.
     * @param chessBoard Representation of the current board state.
     * @param color Color of the player to generate moves for.
     * @return List of all legal moves for a given player.
     */
    public List<Move> getLegalMoves(ChessBoard chessBoard, boolean color) {
        List<Move> legalMoves = new ArrayList<>();
        this.board = chessBoard;

        boolean isWhiteChecked = board.isWhiteCheck;
        boolean isBlackChecked = board.isBlackCheck;

        // Compute blocks if a king is in check
        if (isWhiteChecked) legalMoves.addAll(recomputeBlocks(board.blockingMoves, true));
        if (isBlackChecked) legalMoves.addAll(recomputeBlocks(board.blockingMoves, false));

        for (Square s : pseudoMoves.keySet()) {
            if (s.getPiece().color != color) continue;

            List<Move> legals = getLegalMovesForSquare(s, s.getPiece().color ? isWhiteChecked : isBlackChecked, board.checkingMoves, board.pinnedPieces);
            legalMoves.addAll(legals);
        }

        return legalMoves;
    }

    /**
     * Subset of getLegalMoves that only returns the legal captures.
     * Used in the quiescence search (see Search.java for more details).
     * @param board Representation of the current board state.
     * @param color Color of the player to captures moves for.
     * @return List of all legal captures for a given player.
     */
    public List<Move> getLegalCaptures(ChessBoard board, boolean color){
        List<Move> legalCaptures = getLegalMoves(board, color);
        legalCaptures.removeIf(m->!squares[m.squarePos].hasPiece());
        return legalCaptures;
    }

    /**
     * Finds all possible moves that can block a checking attack.
     * @param blockingMoves
     * @param color
     * @return
     */
    private List<Move> recomputeBlocks(List<Move> blockingMoves, boolean color){
        List<Move> possibleBlocks = new ArrayList<>();

        // No blocks are available if there is a double check
        if (board.isDoubleCheck) return possibleBlocks;

        for (Move m : blockingMoves){
            possibleBlocks.addAll(findLegalMoveIntersection(squares[m.squarePos], color, false, true, false));
        }

        return possibleBlocks;
    }


    public List<Move> findLegalMoveIntersection(Square square, boolean color, boolean includeColor, boolean forBlocks, boolean isKing) {
        List<Move> legalMoveIntersection = new ArrayList<>();

        for (Square s : pseudoMoves.keySet()) {
            if (s.getPiece().color != color) continue;

            List<Move> legals = getLegalMovesForSquare(s, isKing, includeColor);
            for (Move move : legals){
                if (forBlocks && squares[move.piecePos].getPiece().type == Piece.KING) continue;
                if (move.squarePos == square.getArrayPosition()) legalMoveIntersection.add(move);
            }
        }

        return legalMoveIntersection;
    }

    public List<Move> findMoveIntersection(Square square, boolean color){
        List<Move> intersectedSquares = new ArrayList<>();

        for (List<Move> moves : pseudoMoves.values()){
            for (Move m : moves) {
                if (m.squarePos == square.getArrayPosition() && squares[m.piecePos].getPiece().color == color) intersectedSquares.add(m);
            }

        }
        return intersectedSquares;
    }

    public List<Move> getLegalMovesForSquare(Square square, int directionOffset){
        List<Move> res = new ArrayList<>();
        for (Move m : getLegalMovesForSquare(square, false, false)){
            if (m.directionOffset == directionOffset) res.add(m);
        }
        return res;
    }

    private List<Move> getLegalKingMoves(Square kingSquare, boolean isColorChecked, List<Move> checkingMoves){

        List<Move> legalMoves = new ArrayList<>();
        int kingPos = kingSquare.getArrayPosition();

        if (canCastle(kingSquare, true) && !isColorChecked) legalMoves.add(new Move(kingPos,kingPos+3, 1).setCastle());
        if (canCastle(kingSquare, false) && !isColorChecked) legalMoves.add(new Move(kingPos, kingPos-4, -1).setCastle());

        for (Move m : getLegalMovesForSquare(kingSquare, false, false)){
            if (findLegalMoveIntersection(squares[m.squarePos], !kingSquare.getPiece().color, true, false, true).isEmpty()) legalMoves.add(m);
            if (!isColorChecked) continue;
            if (containsMove(m, checkingMoves)) legalMoves.remove(m);
        }

        return legalMoves;
    }

    private boolean containsMove(Move m, List<Move> moves){
        for (Move move : moves){
            if (m.squarePos == move.squarePos && move.directionOffset != 0) return true;
        }

        return false;
    }

    public boolean canCastle(Square kingSquare, boolean kingSide){
        if (!kingSquare.hasPiece() || kingSquare.getPiece().hasMoved) return false;

        int addRookIdx = kingSide ? 3 : -4;
        if (kingSquare.getArrayPosition() + addRookIdx >= 64 || kingSquare.getArrayPosition() + addRookIdx < 0) return false;

        Square rookSquare = squares[kingSquare.getArrayPosition()+addRookIdx];

        if (!rookSquare.hasPiece() || rookSquare.getPiece().hasMoved || rookSquare.getPiece().type != Piece.ROOK) return false;

        if (kingSide){
            for (int i = kingSquare.getArrayPosition()+1; i < kingSquare.getArrayPosition() + addRookIdx; i++){
                if (squares[i].hasPiece() || !findLegalMoveIntersection(squares[i], !kingSquare.getPiece().color, false, false, true).isEmpty()) return false;
            }
        } else {
            for (int i = kingSquare.getArrayPosition()-1; i > kingSquare.getArrayPosition() + addRookIdx; i--){
                if (squares[i].hasPiece() || !findLegalMoveIntersection(squares[i], !kingSquare.getPiece().color, false, false, true).isEmpty()) return false;
            }
        }

        return true;
    }

    public List<Move> getMovesForSquare(Square square, int directionOffset){
        List<Move> pseudoDirection = new ArrayList<>(pseudoMoves.get(square));
        pseudoDirection.removeIf(m -> m.directionOffset != directionOffset);
        return pseudoDirection;
    }

    private Move containsSquare(List<Move> moves, Square square){
        for (Move m : moves){
            if (square.getArrayPosition() == m.squarePos) return m;
        }
        return null;
    }

    public List<Move> getLegalMovesForSquare(Square square, boolean isColorChecked, List<Move> checkingMoves, List<Move> pinnedPieces){
        List<Move> legalMoves = new ArrayList<>();

        if (square.hasKing()) return getLegalKingMoves(square, isColorChecked, checkingMoves);
        if (isColorChecked) return legalMoves;

        Move pinnedPiece = containsSquare(pinnedPieces, square);

        if (pinnedPiece == null) legalMoves.addAll(getLegalMovesForSquare(square, false, false));
        else legalMoves.addAll(getLegalMovesForSquare(square, pinnedPiece.directionOffset));

        return legalMoves;
    }

    public List<Move> getLegalMovesForSquare(Square square, boolean inKingIntersection, boolean includeColor){
        List<Move> pseudoMovesForSquare = pseudoMoves.get(square);
        List<Move> legalMoves = new ArrayList<>();

        HashSet<Integer> invalidDirections = new HashSet<>();

        for (Move m : pseudoMovesForSquare){
            Square s = squares[m.squarePos];

            if (invalidDirections.contains(m.directionOffset)) continue;

            if (square.getPiece().type == Piece.PAWN){
                if (Math.abs(m.directionOffset) != 8) {
                    if (!s.hasPiece() && !inKingIntersection) continue;
                } else {
                    if (squares[m.squarePos].hasPiece() || inKingIntersection) continue;

                    int firstSquarePos = square.getPiece().color == playerColor ? m.squarePos-8 : m.squarePos+8;
                    if (firstSquarePos != m.piecePos && (squares[firstSquarePos].hasPiece() || square.getPiece().hasMoved)) continue;
                }
            }


            if (s.hasPiece()) {
                invalidDirections.add(m.directionOffset);
                if (s.getPiece().color == square.getPiece().color && !includeColor) continue;
            }

            legalMoves.add(m);
        }
        return legalMoves;
    }

    private List<Move> calculateMove(Square square){
        this.possibleMoves = new ArrayList<>();
        this.primaryPieceColor = square.getPiece().color;
        this.squarePosition = square.getArrayPosition();
        this.square = square;

        int pieceType = square.getPiece().type;

        int[] allPossibleDirections = directionOffsets.get(pieceType);
        for (int a : allPossibleDirections){
            switch(pieceType){
                case Piece.QUEEN,Piece.BISHOP,Piece.ROOK ->  calculateSlidingMove(a);
                case Piece.KNIGHT, Piece.KING -> calculateNonSlidingMove(a);
                case Piece.PAWN -> calculatePawnMove(a);
                default -> throw new RuntimeException("Not a recognized piece type");
            }

        }
        return possibleMoves;
    }

    private void calculatePawnMove(int directionOffset) {
        if (primaryPieceColor != playerColor) directionOffset = -directionOffset;

        int newPos = squarePosition + directionOffset;
        Piece pawn = square.getPiece();

        if (!isValid(squarePosition, newPos, Piece.PAWN)) return;

        int[] rf = BoardUtility.getRankAndFile(squarePosition);
        int pos = playerColor == pawn.color ? 1 : 6;
        if (rf[0] == pos && Math.abs(directionOffset) == 8 && isValid(squarePosition, newPos+directionOffset, Piece.PAWN)) {
            //Add square 2 spaces ahead
            possibleMoves.add(new Move(squarePosition,newPos+directionOffset, directionOffset));
        }

        Move pawnMove = new Move(squarePosition, newPos, directionOffset);

        int promotionSquare = primaryPieceColor == playerColor ? 7 : 0;
        if (squares[newPos].getTransform().position.y/90 == promotionSquare) pawnMove.setPromotion();

        possibleMoves.add(pawnMove);
    }

    private void calculateNonSlidingMove(int directionOffset){
        int newPos = squarePosition+directionOffset;

        if (!isValid(squarePosition, newPos, square.getPiece().type)) return;

        possibleMoves.add(new Move(squarePosition, newPos, directionOffset));
    }

    private void calculateSlidingMove(int directionOffset){
        int newPos = squarePosition+directionOffset;
        int prevPos = squarePosition;

        while (isValid(prevPos, newPos, square.getPiece().type)) {
            possibleMoves.add(new Move(squarePosition, newPos, directionOffset));

            prevPos = newPos;
            newPos += directionOffset;
        }
    }

    private boolean isValid(int prevPos, int currentPos, int type){
        int[] newRF = BoardUtility.getRankAndFile(currentPos);
        int[] prevRF = BoardUtility.getRankAndFile(prevPos);
        boolean isValidForType;

        switch (type){
            case Piece.BISHOP, Piece.QUEEN, Piece.ROOK, Piece.KING -> isValidForType = checkSpacing(prevRF[0], newRF[0], prevRF[1], newRF[1], 1, true);
            case Piece.KNIGHT, Piece.PAWN -> isValidForType = checkSpacing(prevRF[0], newRF[0], prevRF[1], newRF[1], 2, false);
            default -> isValidForType = false;
        }
        return (currentPos >= 0 && currentPos < 64) && isValidForType;
    }

    private boolean checkSpacing(int prevRank, int newRank, int prevFile, int newFile, int target, boolean equals){
        int max = Math.max(Math.abs(prevRank - newRank), Math.abs(prevFile - newFile));
        return equals ? (max == target) : (max <= target);
    }
}
